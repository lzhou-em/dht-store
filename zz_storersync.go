package dhtstore

// file generated by
// github.com/mh-cbon/ggt
// do not edit

// StorerSync is channeled.
type StorerSync struct {
	embed *Store
	ops   chan func()
	stop  chan bool
	tick  chan bool
}

// NewStorerSync constructs a channeled version of *Store
func NewStorerSync(keyer Keyer) *StorerSync {
	ret := &StorerSync{
		ops:  make(chan func()),
		tick: make(chan bool),
		stop: make(chan bool),
	}
	ret.embed = NewStore(keyer)
	go ret.Start()
	return ret
}

// Add is channeled
func (s *StorerSync) Add(name, value string, copyCnt ...int) (string, error) {
	var retVar0 string
	var retVar1 error
	s.ops <- func() {
		retVar0, retVar1 = s.embed.Add(name, value, copyCnt...)
	}
	<-s.tick
	return retVar0, retVar1
}

// Get is channeled
func (s *StorerSync) Get(key string) (string, error) {
	var retVar2 string
	var retVar3 error
	s.ops <- func() {
		retVar2, retVar3 = s.embed.Get(key)
	}
	<-s.tick
	return retVar2, retVar3
}

// Remove is channeled
func (s *StorerSync) Remove(key string) error {
	var retVar4 error
	s.ops <- func() {
		retVar4 = s.embed.Remove(key)
	}
	<-s.tick
	return retVar4
}

// Keys is channeled
func (s *StorerSync) Keys() []string {
	var retVar5 []string
	s.ops <- func() {
		retVar5 = s.embed.Keys()
	}
	<-s.tick
	return retVar5
}

// Values is channeled
func (s *StorerSync) Values() []string {
	var retVar6 []string
	s.ops <- func() {
		retVar6 = s.embed.Values()
	}
	<-s.tick
	return retVar6
}

// Map is channeled
func (s *StorerSync) Map() map[string]string {
	var retVar7 map[string]string
	s.ops <- func() {
		retVar7 = s.embed.Map()
	}
	<-s.tick
	return retVar7
}

// Stats is channeled
func (s *StorerSync) Stats(keys ...string) []StoreValue {
	var retVar8 []StoreValue
	s.ops <- func() {
		retVar8 = s.embed.Stats(keys...)
	}
	<-s.tick
	return retVar8
}

// Stat is channeled
func (s *StorerSync) Stat(key string) StoreValue {
	var retVar9 StoreValue
	s.ops <- func() {
		retVar9 = s.embed.Stat(key)
	}
	<-s.tick
	return retVar9
}

// ClearStat is channeled
func (s *StorerSync) ClearStat(key string) bool {
	var retVar10 bool
	s.ops <- func() {
		retVar10 = s.embed.ClearStat(key)
	}
	<-s.tick
	return retVar10
}

// UpdateReplicationCount is channeled
func (s *StorerSync) UpdateReplicationCount(key string, count int) int {
	var retVar11 int
	s.ops <- func() {
		retVar11 = s.embed.UpdateReplicationCount(key, count)
	}
	<-s.tick
	return retVar11
}

// UpdateSeq is channeled
func (s *StorerSync) UpdateSeq(key string, seq int) {
	s.ops <- func() {
		s.embed.UpdateSeq(key, seq)
	}
	<-s.tick
}

// UpdateCas is channeled
func (s *StorerSync) UpdateCas(key string, cas int) {
	s.ops <- func() {
		s.embed.UpdateCas(key, cas)
	}
	<-s.tick
}

// AddErr is channeled
func (s *StorerSync) AddErr(key string, err error) bool {
	var retVar12 bool
	s.ops <- func() {
		retVar12 = s.embed.AddErr(key, err)
	}
	<-s.tick
	return retVar12
}

// Transact execute one op.
func (s *StorerSync) Transact(F ...func(*Store)) {
	ref := s.embed
	s.ops <- func() {
		for _, f := range F {
			f(ref)
		}
	}
	<-s.tick
	s.embed = ref
}

// Start the main loop
func (s *StorerSync) Start() {
	for {
		select {
		case op := <-s.ops:
			op()
			s.tick <- true
		case <-s.stop:
			return
		}
	}
}

// Stop the main loop
func (s *StorerSync) Stop() {
	s.stop <- true
}
